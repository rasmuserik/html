// Generated by CoffeeScript 1.6.3
(function() {
  var Node, args, circlesPerLine, count, ctx, curveness, fnNames, fns, height, hspace, i, length, nodeCount, nodes, prev, radius, root, size, t0, width, _i, _j, _ref;

  t0 = +new Date();

  height = canvas.width;

  size = 80;

  count = 20;

  hspace = 1.3;

  width = size * 5;

  radius = size * .40;

  ctx = canvas.getContext("2d");

  ctx.lineWidth = 2;

  circlesPerLine = 3;

  curveness = 1.9;

  ctx.fillRect(0, 0, 1000, 1000);

  nodes = {};

  fns = {};

  nodeCount = 0;

  if (true) {
    Node = function(prev, op, inputs) {
      var i, _i, _len, _ref;
      this.op = op;
      this.id = nodeCount;
      ++nodeCount;
      if (prev !== void 0) {
        this.prev = prev.id;
        nodes[this.prev].next = this.id;
      }
      this["in"] = inputs;
      this.out = [];
      _ref = this["in"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        nodes[i].out.push(this.id);
      }
      nodes[this.id] = this;
      return this.val = this["eval"]();
    };
    Node.prototype.drawShadow = function() {
      if (this.mark) {
        ctx.setShadow(0, 0, radius * 1, hashcolor.light("" + this.val));
        ctx.beginPath();
        ctx.arc(this.x, this.y, radius + 1, 0, Math.PI * 2);
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.clearShadow();
      }
      if (this.next !== void 0) {
        return nodes[this.next].drawShadow();
      }
    };
    Node.prototype.drawObj = function() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();
      ctx.strokeStyle = hashcolor.intToColor(hashcolor.val("" + this.val));
      ctx.stroke();
      ctx.font = "" + (size / 3) + "px ubuntu";
      ctx.fillStyle = "#000";
      ctx.fillText(this.op, this.x - size * .2, this.y - size * .05);
      ctx.fillText(this.val, this.x - size * .2, this.y + size * .25);
      if (this.next !== void 0) {
        return nodes[this.next].drawObj();
      }
    };
    Node.prototype.outPoint = function() {
      var d;
      d = Math.SQRT1_2 * radius;
      return [this.x + d, this.y + d, this.x + d * curveness, this.y + d * curveness];
    };
    Node.prototype.inPoint = function(i) {
      var a, t, w, x, y;
      t = radius * Math.sqrt(.5);
      w = 2;
      a = Math.PI * 1.25 + w * (i + 1) / (this["in"].length + 1) - w / 2;
      y = Math.sin(a);
      x = Math.cos(a);
      return [this.x + x * radius, this.y + y * radius, this.x + x * radius * curveness, this.y + y * radius * curveness];
    };
    Node.prototype.drawLines = function() {
      var cx0, cx1, cy0, cy1, i, src, x0, x1, y0, y1, _i, _ref, _ref1, _ref2;
      for (i = _i = 0, _ref = this["in"].length - 1; _i <= _ref; i = _i += 1) {
        src = nodes[this["in"][i]];
        _ref1 = src.outPoint(), x0 = _ref1[0], y0 = _ref1[1], cx0 = _ref1[2], cy0 = _ref1[3];
        _ref2 = this.inPoint(i), x1 = _ref2[0], y1 = _ref2[1], cx1 = _ref2[2], cy1 = _ref2[3];
        ctx.beginPath();
        ctx.strokeStyle = hashcolor.intToColor(hashcolor.val("" + src.val));
        ctx.moveTo(x0, y0);
        ctx.quadraticCurveTo(cx0, cy0, (cx0 + cx1) / 2, (cy0 + cy1) / 2);
        ctx.quadraticCurveTo(cx1, cy1, x1, y1);
        ctx.stroke();
      }
      if (this.next !== void 0) {
        return nodes[this.next].drawLines();
      }
    };
    Node.prototype.layout = function(x, y) {
      this.x = x;
      this.y = y;
      x += size;
      if (x > width - size / 2) {
        x -= width - size / 2;
        y += size * hspace;
        if (x < size / 2) {
          x += size;
        }
      }
      if (this.next !== void 0) {
        return nodes[this.next].layout(x, y);
      }
    };
    Node.prototype["eval"] = function() {
      if (typeof this.op === "number") {
        return this.op;
      } else if (typeof fns[this.op] === "function") {
        return fns[this.op].apply(null, this["in"].map(function(o) {
          return nodes[o]["eval"]();
        }));
      } else {
        throw this.op;
      }
    };
    fns["+"] = function(a, b) {
      return a + b;
    };
    fns["-"] = function(a, b) {
      return a - b;
    };
    fns["xor"] = function(a, b) {
      return a ^ b;
    };
    fns["&"] = function(a, b) {
      return a & b;
    };
    fns["or"] = function(a, b) {
      return a | b;
    };
    fnNames = Object.keys(fns);
    root = new Node(void 0, 1, []);
    prev = root;
    for (i = _i = 0; 0 <= count ? _i <= count : _i >= count; i = 0 <= count ? ++_i : --_i) {
      if (Math.random() < .3 || nodeCount < 2) {
        prev = new Node(prev, 1 + Math.random() * 9 | 0, []);
      } else {
        length = 1 + Math.random() * Math.random() * 4 | 0;
        length = 2;
        args = [];
        for (i = _j = 0, _ref = length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
          args.push(nodeCount - Math.random() * Math.random() * nodeCount | 0);
        }
        prev = new Node(prev, fnNames[Math.random() * fnNames.length | 0], args);
      }
      if (Math.random() < .2) {
        prev.mark = true;
      }
    }
    t0 = Date.now();
    root.layout(size / 2, size / 2);
    root.drawShadow();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
    root.drawLines();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
    root.drawObj();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
  }

}).call(this);
